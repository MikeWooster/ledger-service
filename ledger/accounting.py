from decimal import Decimal

from sqlalchemy.orm.exc import NoResultFound

from ledger.accounting_types import (
    AbstractEntryType,
    TypeCode,
    get_accounting_type,
)
from ledger import models


class LedgerEntry:

    def __init__(self, account_number: str, amount: Decimal, accounting_type: AbstractEntryType):
        self.account_number = account_number
        self.amount = amount
        self.accounting_type = accounting_type

    def get_signed_amount(self) -> Decimal:
        return self.amount * self.accounting_type.get_sign()

    def get_accounting_type_code(self) -> str:
        return self.accounting_type.get_type_code()


class Balance:

    @staticmethod
    def update_balance(entry: LedgerEntry):
        balance_record = Balance._get_or_create_record(entry.account_number)
        balance_record.balance += entry.get_signed_amount()
        balance_record.save()

    @staticmethod
    def _get_or_create_record(account_number: str) -> models.Balance:
        try:
            balance_entry = models.Balance.query.filter_by(account_number=account_number).one()
        except NoResultFound:
            balance_entry = models.Balance(account_number=account_number, balance=0)
        return balance_entry

    @staticmethod
    def get_for_account(account_number: str) -> Decimal:
        balance_record = Balance._get_or_create_record(account_number)
        return balance_record.balance


class Ledger:
    """
    This will need to store:
        - accounting type (credit or debit)
        ? movement type (payment in, payment out, internal transfer) <- may not be necessary
        - when the entry was created
        ? when the entry was updated
        ? when the activity actually occurred (i.e. from 3rd party perspective)
        - amount of the transaction
        - the up to date balance of this account
        ? the id of the transaction (generated by 3rd party system)
        - the account it relates to (account number or id of account)
        - a unique id for this transaction
        - the id of a related transaction (may be null)
    """

    @classmethod
    def add_entry(cls, account_number: str, amount: Decimal, type_code: TypeCode) -> LedgerEntry:
        accounting_type = get_accounting_type(type_code)
        ledger_entry = LedgerEntry(account_number, amount, accounting_type)
        cls._store(ledger_entry)
        Balance.update_balance(ledger_entry)
        return ledger_entry

    @classmethod
    def _store(cls, ledger_entry: LedgerEntry):
        """Store ledger record in db."""
        ledger_record = models.Ledger(
            account_number=ledger_entry.account_number,
            amount=ledger_entry.amount,
            accounting_type=ledger_entry.get_accounting_type_code(),
        )
        ledger_record.save()

    @classmethod
    def get_all_entries(cls) -> list:
        """Return all ledger entries."""
        # TODO: this method should be deprecated as it is going to get really inefficient.
        entries = []
        for record in models.Ledger.query.all():
            entry = cls._record_to_entry(record)
            entries.append(entry)
        return entries

    @classmethod
    def _record_to_entry(cls, record: models.Ledger):
        accounting_type = get_accounting_type(record.accounting_type)
        return LedgerEntry(record.account_number, record.amount, accounting_type)
