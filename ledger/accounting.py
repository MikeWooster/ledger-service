from sqlalchemy.orm.exc import NoResultFound

from ledger.accounting_types import (
    AbstractEntryType,
    TypeCode,
    get_accounting_type,
)
from ledger import models


class LedgerEntry:

    def __init__(self, account_number: str, amount: int, accounting_type: AbstractEntryType):
        self.account_number = account_number
        self.amount = amount
        self.accounting_type = accounting_type

    def get_signed_amount(self) -> int:
        return self.amount * self.accounting_type.get_sign()

    def __str__(self) -> str:
        return (
            f"<LedgerEntry: account_number={self.account_number}, "
            f"amount={self.amount}, accounting_type={self.accounting_type}>"
        )


class Balance:
    _balances = {}

    @staticmethod
    def update_balance(entry: LedgerEntry):
        balance_record = Balance._get_or_create_record(entry.account_number)
        balance_record.balance += entry.get_signed_amount()
        balance_record.save()

    @staticmethod
    def _get_or_create_record(account_number: str) -> models.Balance:
        try:
            balance_entry = models.Balance.query.filter_by(account_number=account_number).one()
        except NoResultFound:
            balance_entry = models.Balance(account_number=account_number, balance=0)
        return balance_entry

    @staticmethod
    def get_for_account(account_number: str) -> int:
        balance_record = Balance._get_or_create_record(account_number)
        return balance_record.balance


class Ledger:
    """
    This will need to store:
        - accounting type (credit or debit)
        ? movement type (payment in, payment out, internal transfer) <- may not be necessary
        - when the entry was created
        ? when the entry was updated
        ? when the activity actually occurred (i.e. from 3rd party perspective)
        - amount of the transaction
        - the up to date balance of this account
        ? the id of the transaction (generated by 3rd party system)
        - the account it relates to (account number or id of account)
        - a unique id for this transaction
        - the id of a related transaction (may be null)
    """
    _ledger = []

    @classmethod
    def add_entry(cls, account_number: str, amount: int, type_code: TypeCode) -> LedgerEntry:
        accounting_type = get_accounting_type(type_code)
        entry = LedgerEntry(account_number, amount, accounting_type)
        cls._ledger.append(entry)
        Balance.update_balance(entry)
        return entry

    @classmethod
    def get_all_entries(cls) -> list:
        """Return a copy of the inner entries to avoid mutating the original."""
        entries = []
        for entry in cls._ledger:
            entries.append(entry)
        return entries
